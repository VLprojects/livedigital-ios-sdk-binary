// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 6.1.2 effective-5.10 (swiftlang-6.1.2.1.2 clang-1700.0.13.5)
// swift-module-flags: -target x86_64-apple-ios15.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -enable-experimental-feature DebugDescriptionMacro -enable-bare-slash-regex -module-name LiveDigitalSDK
// swift-module-flags-ignorable: -no-verify-emitted-module-interface -interface-compiler-version 6.1.2
import AVFoundation
import CoreImage.CIFilterBuiltins
import Combine
import CoreImage
import CoreVideo
import Foundation
@_exported import LiveDigitalSDK
import Mediasoup
import Swift
import UIKit
import Vision
import WebRTC
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
import zlib
public struct ChannelId : Swift.ExpressibleByStringLiteral {
  public let value: Swift.String
  public init(stringLiteral value: Swift.StringLiteralType)
  public init(value: Swift.String)
  public typealias ExtendedGraphemeClusterLiteralType = Swift.StringLiteralType
  public typealias StringLiteralType = Swift.StringLiteralType
  public typealias UnicodeScalarLiteralType = Swift.StringLiteralType
}
extension LiveDigitalSDK.ChannelId : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension LiveDigitalSDK.ChannelId : Swift.Equatable {
  public static func == (lhs: LiveDigitalSDK.ChannelId, rhs: LiveDigitalSDK.ChannelId) -> Swift.Bool
}
extension LiveDigitalSDK.ChannelId : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
public protocol ChannelSession : AnyObject {
  var delegate: (any LiveDigitalSDK.ChannelSessionDelegate)? { get set }
  var status: LiveDigitalSDK.ChannelSessionStatus { get }
  var node: Swift.String? { get }
  var myPeerId: LiveDigitalSDK.PeerId? { get }
  var peerDetails: LiveDigitalSDK.JoinedPeerParameters? { get }
  var shouldShowLocalPeer: Swift.Bool { get set }
  var peers: Swift.Set<LiveDigitalSDK.Peer> { get }
  var videoSources: [any LiveDigitalSDK.VideoSource] { get }
  var audioSources: [LiveDigitalSDK.AudioSource] { get }
  var producePermissions: Swift.Set<LiveDigitalSDK.TrackLabel>? { get }
  func addVideoSource(_ source: any LiveDigitalSDK.VideoSource)
  func pauseVideoSource(_ removedSource: any LiveDigitalSDK.VideoSource)
  func removeVideoSource(_ removedSource: any LiveDigitalSDK.VideoSource)
  func addAudioSource(_ source: LiveDigitalSDK.AudioSource)
  func pauseAudioSource(_ removedSource: LiveDigitalSDK.AudioSource)
  func removeAudioSource(_ removedSource: LiveDigitalSDK.AudioSource)
  func updateAudioOutput(enabled: Swift.Bool)
  func requestVideoLayer(_ layer: LiveDigitalSDK.VideoLayer, with trackLabel: LiveDigitalSDK.TrackLabel, for peer: LiveDigitalSDK.Peer)
  func suspendVideo(with trackLabel: LiveDigitalSDK.TrackLabel, for peer: LiveDigitalSDK.Peer)
  func proceedVideo(with trackLabel: LiveDigitalSDK.TrackLabel, for peer: LiveDigitalSDK.Peer)
  func suspendAudio(with trackLabel: LiveDigitalSDK.TrackLabel, for peer: LiveDigitalSDK.Peer)
  func proceedAudio(with trackLabel: LiveDigitalSDK.TrackLabel, for peer: LiveDigitalSDK.Peer)
  func updatePeerPayload(_ peerPayload: [Swift.String : Any])
  func start(mediaRole: LiveDigitalSDK.MediaRole?, participantId: LiveDigitalSDK.ParticipantId?, signalingToken: Swift.String?, peerId: LiveDigitalSDK.PeerId?, peerPayload: [Swift.String : Any]?)
  func stop(callbackQueue: Dispatch.DispatchQueue, completion: @escaping () -> Swift.Void)
  func stop(completion: @escaping () -> Swift.Void)
  func confirmActivity()
  func setTrackProducing(enabled: Swift.Bool, track: LiveDigitalSDK.TrackLabel, for peer: LiveDigitalSDK.Peer)
  func restartConnections()
  func generateTracksTrafficReport(completion: @escaping (Swift.Set<LiveDigitalSDK.TrackTrafficReport>) -> Swift.Void)
}
public protocol ChannelSessionDelegate : AnyObject {
  func sessionNeedsRestart(_ channelSession: any LiveDigitalSDK.ChannelSession)
  func channelSessionShouldSuspendVideo(_ channelSession: any LiveDigitalSDK.ChannelSession, with trackLabel: LiveDigitalSDK.TrackLabel, from peer: LiveDigitalSDK.Peer) -> Swift.Bool
  func channelSessionShouldSuspendAudio(_ channelSession: any LiveDigitalSDK.ChannelSession, with trackLabel: LiveDigitalSDK.TrackLabel, from peer: LiveDigitalSDK.Peer) -> Swift.Bool
}
public enum ChannelSessionError : Swift.Error {
  case unknown
  case sessionDeallocated
  case connectionAttemptFailed
  case sessionInitializationFailed
  case connectionFailed
  public static func == (a: LiveDigitalSDK.ChannelSessionError, b: LiveDigitalSDK.ChannelSessionError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol ChannelSessionObserver : AnyObject {
  func channelSessionNeedsUpdateState(_ channelSession: any LiveDigitalSDK.ChannelSession)
  func channelSessionJoinedChannel(_ channelSession: any LiveDigitalSDK.ChannelSession)
  func channelSessionFailed(_ channelSession: any LiveDigitalSDK.ChannelSession, error: LiveDigitalSDK.ChannelSessionError)
  func channelSessionStoppedByServer(_ channelSession: any LiveDigitalSDK.ChannelSession)
  func channelSessionStatusChanged(_ channelSession: any LiveDigitalSDK.ChannelSession)
  func channelSessionStartedBroadcasting(_ channelSession: any LiveDigitalSDK.ChannelSession, trackLabel: LiveDigitalSDK.TrackLabel)
  func channelSessionStoppedBroadcasting(_ channelSession: any LiveDigitalSDK.ChannelSession, trackLabel: LiveDigitalSDK.TrackLabel)
  func channelSessionPausedBroadcasting(_ channelSession: any LiveDigitalSDK.ChannelSession, trackLabel: LiveDigitalSDK.TrackLabel)
  func channelSessionForceStoppedBroadcasting(_ channelSession: any LiveDigitalSDK.ChannelSession, trackLabel: LiveDigitalSDK.TrackLabel)
  func peersJoined(_ peers: [LiveDigitalSDK.Peer])
  func peersDisconnected(_ peerIds: Swift.Set<LiveDigitalSDK.PeerId>)
  func peerAddedVideoTrack(peer: LiveDigitalSDK.Peer, trackLabel: LiveDigitalSDK.TrackLabel, paused: Swift.Bool)
  func peerAddedVideoView(peer: LiveDigitalSDK.Peer, videoView: UIKit.UIView, trackLabel: LiveDigitalSDK.TrackLabel, paused: Swift.Bool)
  func peerAddedAudioTrack(peer: LiveDigitalSDK.Peer, trackLabel: LiveDigitalSDK.TrackLabel, paused: Swift.Bool)
  func peerRemovedAudioTrack(peer: LiveDigitalSDK.Peer, trackLabel: LiveDigitalSDK.TrackLabel)
  func peerRemovedVideoTrack(peer: LiveDigitalSDK.Peer, trackLabel: LiveDigitalSDK.TrackLabel)
  func allMediaTracksRemoved()
  func producePermissionsUpdated(enabledTracks: Swift.Set<LiveDigitalSDK.TrackLabel>)
  func peersProducePermissionsUpdated(peers: [LiveDigitalSDK.Peer])
  func peerStartedVideo(peer: LiveDigitalSDK.Peer, trackLabel: LiveDigitalSDK.TrackLabel)
  func peerStoppedVideo(peer: LiveDigitalSDK.Peer, trackLabel: LiveDigitalSDK.TrackLabel)
  func peerStartedAudio(peer: LiveDigitalSDK.Peer, trackLabel: LiveDigitalSDK.TrackLabel)
  func peerStoppedAudio(peer: LiveDigitalSDK.Peer, trackLabel: LiveDigitalSDK.TrackLabel)
  func gotCustomEvent(event: LiveDigitalSDK.CustomEvent)
  func gotPeerAppDataUpdates(_ updates: [LiveDigitalSDK.PeerAppData])
  func gotActivityRequiredEvent(event: LiveDigitalSDK.ActivityRequiredEventData)
  func gotActivityExpiredEvent()
  func gotActivityAcquiredEvent()
  func gotDominantSpeakerEvent(peerTrack: LiveDigitalSDK.PeerTrackId)
  func gotPeersVolumesEvent(_ volumes: [LiveDigitalSDK.PeerTrackId : Swift.Int])
  func gotSilenceEvent()
  func gotNetworkMetricsReports(_ reports: [LiveDigitalSDK.NetworkMetricsReport], sessionDetails: LiveDigitalSDK.SessionDetails)
  func gotConsistencyIssues(_ issues: [LiveDigitalSDK.SessionStateConsistencyIssue])
}
extension LiveDigitalSDK.ChannelSessionObserver {
  public func channelSessionJoinedChannel(_ channelSession: any LiveDigitalSDK.ChannelSession)
  public func channelSessionFailed(_ channelSession: any LiveDigitalSDK.ChannelSession, error: LiveDigitalSDK.ChannelSessionError)
  public func channelSessionStoppedByServer(_ channelSession: any LiveDigitalSDK.ChannelSession)
  public func channelSessionStatusChanged(_ channelSession: any LiveDigitalSDK.ChannelSession)
  public func peersJoined(_ peers: [LiveDigitalSDK.Peer])
  public func peersDisconnected(_ peerIds: Swift.Set<LiveDigitalSDK.PeerId>)
  public func peerAddedVideoTrack(peer: LiveDigitalSDK.Peer, trackLabel: LiveDigitalSDK.TrackLabel, paused: Swift.Bool)
  public func peerAddedVideoView(peer: LiveDigitalSDK.Peer, videoView: UIKit.UIView, trackLabel: LiveDigitalSDK.TrackLabel, paused: Swift.Bool)
  public func peerAddedAudioTrack(peer: LiveDigitalSDK.Peer, trackLabel: LiveDigitalSDK.TrackLabel, paused: Swift.Bool)
  public func peerRemovedAudioTrack(peer: LiveDigitalSDK.Peer, trackLabel: LiveDigitalSDK.TrackLabel)
  public func peerRemovedVideoTrack(peer: LiveDigitalSDK.Peer, trackLabel: LiveDigitalSDK.TrackLabel)
  public func allMediaTracksRemoved()
  public func peerStartedVideo(peer: LiveDigitalSDK.Peer, trackLabel: LiveDigitalSDK.TrackLabel)
  public func peerStoppedVideo(peer: LiveDigitalSDK.Peer, trackLabel: LiveDigitalSDK.TrackLabel)
  public func peerStartedAudio(peer: LiveDigitalSDK.Peer, trackLabel: LiveDigitalSDK.TrackLabel)
  public func peerStoppedAudio(peer: LiveDigitalSDK.Peer, trackLabel: LiveDigitalSDK.TrackLabel)
  public func peersProducePermissionsUpdated(peers: [LiveDigitalSDK.Peer])
  public func producePermissionsUpdated(enabledTracks: Swift.Set<LiveDigitalSDK.TrackLabel>)
  public func channelSessionStartedBroadcasting(_ channelSession: any LiveDigitalSDK.ChannelSession, trackLabel: LiveDigitalSDK.TrackLabel)
  public func channelSessionStoppedBroadcasting(_ channelSession: any LiveDigitalSDK.ChannelSession, trackLabel: LiveDigitalSDK.TrackLabel)
  public func channelSessionPausedBroadcasting(_ channelSession: any LiveDigitalSDK.ChannelSession, trackLabel: LiveDigitalSDK.TrackLabel)
  public func channelSessionForceStoppedBroadcasting(_ channelSession: any LiveDigitalSDK.ChannelSession, trackLabel: LiveDigitalSDK.TrackLabel)
  public func gotCustomEvent(event: LiveDigitalSDK.CustomEvent)
  public func gotPeerAppDataUpdates(_ updates: [LiveDigitalSDK.PeerAppData])
  public func gotActivityRequiredEvent(event: LiveDigitalSDK.ActivityRequiredEventData)
  public func gotActivityExpiredEvent()
  public func gotActivityAcquiredEvent()
  public func gotDominantSpeakerEvent(peerTrack: LiveDigitalSDK.PeerTrackId)
  public func gotPeersVolumesEvent(_ volumes: [LiveDigitalSDK.PeerTrackId : Swift.Int])
  public func gotSilenceEvent()
  public func gotNetworkMetricsReports(_ reports: [LiveDigitalSDK.NetworkMetricsReport], sessionDetails: LiveDigitalSDK.SessionDetails)
  public func gotConsistencyIssues(_ issues: [LiveDigitalSDK.SessionStateConsistencyIssue])
}
public enum ChannelSessionStatus {
  case stopped
  case starting
  case restarting
  case started
  case stopping
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension LiveDigitalSDK.ChannelSessionStatus : Swift.Equatable {
  public static func == (a: LiveDigitalSDK.ChannelSessionStatus, b: LiveDigitalSDK.ChannelSessionStatus) -> Swift.Bool
}
public enum SessionStateConsistencyIssue : Swift.Hashable, Swift.Equatable {
  case missingPeer(LiveDigitalSDK.PeerId)
  case missingProducer(LiveDigitalSDK.ProducerId)
  case incorrectProducerState(LiveDigitalSDK.ProducerId)
  case incorrectConsumerState(LiveDigitalSDK.ConsumerId)
  case incorrectAppData(LiveDigitalSDK.PeerId)
  public static func == (a: LiveDigitalSDK.SessionStateConsistencyIssue, b: LiveDigitalSDK.SessionStateConsistencyIssue) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct ConsumerId : Swift.RawRepresentable {
  public let rawValue: Swift.String
  public init(rawValue: Swift.String)
  public static func random() -> LiveDigitalSDK.ConsumerId
  public typealias RawValue = Swift.String
}
extension LiveDigitalSDK.ConsumerId : Swift.Hashable {
}
extension LiveDigitalSDK.ConsumerId : Swift.Equatable {
}
public struct LocalConsumerId : Swift.RawRepresentable {
  public let rawValue: Swift.String
  public init(rawValue: Swift.String)
  public static func random() -> LiveDigitalSDK.LocalConsumerId
  public typealias RawValue = Swift.String
}
extension LiveDigitalSDK.LocalConsumerId : Swift.Hashable {
}
extension LiveDigitalSDK.LocalConsumerId : Swift.Equatable {
}
public struct DataProducerId : Swift.RawRepresentable, Swift.Hashable, Swift.Equatable {
  public let rawValue: Swift.String
  public init(rawValue: Swift.String)
  public static func random() -> LiveDigitalSDK.DataProducerId
  public typealias RawValue = Swift.String
}
public struct LocalDataProducerId : Swift.RawRepresentable, Swift.Hashable, Swift.Equatable {
  public let rawValue: Swift.String
  public init(rawValue: Swift.String)
  public static func random() -> LiveDigitalSDK.LocalDataProducerId
  public typealias RawValue = Swift.String
}
public enum MediaKind : Swift.String, Swift.CaseIterable, Swift.Sendable {
  case audio
  case video
  public init?(rawValue: Swift.String)
  public typealias AllCases = [LiveDigitalSDK.MediaKind]
  public typealias RawValue = Swift.String
  nonisolated public static var allCases: [LiveDigitalSDK.MediaKind] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
public struct LocalProducerId : Swift.RawRepresentable {
  public let rawValue: Swift.String
  public init(rawValue: Swift.StringLiteralType)
  public static func random() -> LiveDigitalSDK.LocalProducerId
  public typealias RawValue = Swift.StringLiteralType
}
extension LiveDigitalSDK.LocalProducerId : Swift.Hashable {
}
extension LiveDigitalSDK.LocalProducerId : Swift.Equatable {
}
public struct ProducerId : Swift.RawRepresentable, Swift.Sendable, Swift.Hashable, Swift.Equatable {
  public let rawValue: Swift.String
  public init(rawValue: Swift.String)
  public static func random() -> LiveDigitalSDK.ProducerId
  public typealias RawValue = Swift.String
}
public struct MOSValue : Swift.RawRepresentable {
  public var rawValue: Swift.Double
  public var roundedValue: Swift.Double {
    get
  }
  public init(rawValue: Swift.Double)
  public typealias RawValue = Swift.Double
}
extension LiveDigitalSDK.MOSValue : Swift.Comparable {
  public static func < (lhs: LiveDigitalSDK.MOSValue, rhs: LiveDigitalSDK.MOSValue) -> Swift.Bool
}
extension LiveDigitalSDK.MOSValue : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
public struct NetworkMetricsReport {
  public let time: Foundation.Date
  public let direction: LiveDigitalSDK.NetworkReportDirection
  public let mos: LiveDigitalSDK.MOSValue
  public let stats: LiveDigitalSDK.NetworkQualityStats
  public let bitrate: Swift.Double
  public let streamsCount: Swift.Int
}
public struct NetworkQualityStats {
  public let avgJitter: Foundation.TimeInterval
  public let rtt: Foundation.TimeInterval
  public let packetsLoss: Swift.Double
}
public enum NetworkReportDirection {
  case inbound
  case outbound
  public static func == (a: LiveDigitalSDK.NetworkReportDirection, b: LiveDigitalSDK.NetworkReportDirection) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol NetworkReportsObserver : AnyObject {
  func gotNetworkMetricsReports(_ results: [LiveDigitalSDK.ReportCalculatorResult])
}
public struct ReportCalculatorResult {
  public let time: Foundation.Date
  public let direction: LiveDigitalSDK.NetworkReportDirection
  public let mos: LiveDigitalSDK.MOSValue
  public let stats: LiveDigitalSDK.NetworkQualityStats
  public let bitrate: Swift.Double
}
public protocol ObservableChannelSession {
  func subscribe(_ observer: any LiveDigitalSDK.ChannelSessionObserver)
  func unsubscribe(_ observer: any LiveDigitalSDK.ChannelSessionObserver)
}
public struct SessionDetails {
  public let node: Swift.String
  public let peerDetails: LiveDigitalSDK.JoinedPeerParameters
}
@available(iOS, unavailable, message: "Only available in extensions.")
@available(watchOS, unavailable, message: "Only available in extensions.")
@available(tvOS, unavailable, message: "Only available in extensions.")
final public class BroadcastLiveDigitalEngine {
  weak final public var delegate: (any LiveDigitalSDK.LiveDigitalSessionManagerDelegate)?
  final public var videoSources: [LiveDigitalSDK.VideoSourceWithoutPreview] {
    get
  }
  final public let logger: any LiveDigitalSDK.LDSDKLogger
  convenience public init(environment: LiveDigitalSDK.LiveDigitalSDKEnvironment = .production, clientUniqueId: LiveDigitalSDK.ClientUniqueId = .random(), format: LiveDigitalSDK.VideoOutputFormat)
  public init(environment: LiveDigitalSDK.LiveDigitalSDKEnvironment = .production, clientUniqueId: LiveDigitalSDK.ClientUniqueId = .random(), format: LiveDigitalSDK.VideoOutputFormat, logger: any LiveDigitalSDK.LDSDKLogger)
  final public func captureVideoFrame(_ sampleBuffer: CoreMedia.CMSampleBuffer, orientation: ImageIO.CGImagePropertyOrientation = .up)
  final public func captureAudioSamples(_ sampleBuffer: CoreMedia.CMSampleBuffer)
  @objc deinit
}
@available(iOS, unavailable, message: "Only available in extensions.")
@available(watchOS, unavailable, message: "Only available in extensions.")
@available(tvOS, unavailable, message: "Only available in extensions.")
extension LiveDigitalSDK.BroadcastLiveDigitalEngine : LiveDigitalSDK.LiveDigitalSessionManager {
  final public var currentChannelSession: (any LiveDigitalSDK.ChannelSession)? {
    get
  }
  final public func connectToChannel(_ channelId: LiveDigitalSDK.ChannelId, mediaRole: LiveDigitalSDK.MediaRole?, participantId: LiveDigitalSDK.ParticipantId?, signalingToken: Swift.String?, peerId: LiveDigitalSDK.PeerId?, peerPayload: [Swift.String : Any]?, completion: @escaping LiveDigitalSDK.ConnectionCompletion)
  final public func disconnectFromCurrentChannel(completion: @escaping () -> Swift.Void)
}
@available(iOS, unavailable, message: "Only available in extensions.")
@available(watchOS, unavailable, message: "Only available in extensions.")
@available(tvOS, unavailable, message: "Only available in extensions.")
extension LiveDigitalSDK.BroadcastLiveDigitalEngine : LiveDigitalSDK.LiveDigitalBroadcastEngine {
  final public func startVideoSource() -> Swift.Result<LiveDigitalSDK.VideoSourceWithoutPreview, LiveDigitalSDK.LiveDigitalEngineError>
  final public func startVideoSource(encodingParameters: LiveDigitalSDK.VideoEncodingParameters, preferredCodec: LiveDigitalSDK.VideoCodec) -> Swift.Result<LiveDigitalSDK.VideoSourceWithoutPreview, LiveDigitalSDK.LiveDigitalEngineError>
  final public func stopVideoSource(_ videoSource: LiveDigitalSDK.VideoSourceWithoutPreview)
}
@available(iOSApplicationExtension, unavailable, message: "Unavailable in extensions.")
@available(watchOSApplicationExtension, unavailable, message: "Unavailable in extensions.")
@available(tvOSApplicationExtension, unavailable, message: "Unavailable in extensions.")
final public class CameraPreviewEngine {
  final public let preview: LiveDigitalSDK.VLMTLVideoView
  final public let captureOutput: AVFoundation.AVCaptureVideoDataOutput
  final public var filter: (any LiveDigitalSDK.VideoSourceFilter)?
  convenience public init()
  public init(logger: any LiveDigitalSDK.LDSDKLogger)
  @objc deinit
}
@available(iOSApplicationExtension, unavailable, message: "Unavailable in extensions.")
@available(watchOSApplicationExtension, unavailable, message: "Unavailable in extensions.")
@available(tvOSApplicationExtension, unavailable, message: "Unavailable in extensions.")
extension LiveDigitalSDK.CameraPreviewEngine : LiveDigitalSDK.LiveDigitalVideoFilterEngine {
}
@available(iOS, unavailable, message: "Only available in extensions.")
@available(watchOS, unavailable, message: "Only available in extensions.")
@available(tvOS, unavailable, message: "Only available in extensions.")
public protocol LiveDigitalBroadcastEngine {
  var videoSources: [LiveDigitalSDK.VideoSourceWithoutPreview] { get }
  func startVideoSource() -> Swift.Result<LiveDigitalSDK.VideoSourceWithoutPreview, LiveDigitalSDK.LiveDigitalEngineError>
  func startVideoSource(encodingParameters: LiveDigitalSDK.VideoEncodingParameters, preferredCodec: LiveDigitalSDK.VideoCodec) -> Swift.Result<LiveDigitalSDK.VideoSourceWithoutPreview, LiveDigitalSDK.LiveDigitalEngineError>
  func stopVideoSource(_ videoSource: LiveDigitalSDK.VideoSourceWithoutPreview)
}
@available(iOSApplicationExtension, unavailable, message: "Unavailable in extensions.")
@available(watchOSApplicationExtension, unavailable, message: "Unavailable in extensions.")
@available(tvOSApplicationExtension, unavailable, message: "Unavailable in extensions.")
public protocol LiveDigitalCameraEngine {
  var videoSources: [any LiveDigitalSDK.VideoSource] { get }
  var cameraManager: any LiveDigitalSDK.CameraManager { get }
  func startVideoSource(position: AVFoundation.AVCaptureDevice.Position) -> Swift.Result<LiveDigitalSDK.VideoSourceWithPreview, LiveDigitalSDK.LiveDigitalEngineError>
  func startVideoSource(encodingParameters: LiveDigitalSDK.VideoEncodingParameters, preferredCodec: LiveDigitalSDK.VideoCodec, position: AVFoundation.AVCaptureDevice.Position) -> Swift.Result<LiveDigitalSDK.VideoSourceWithPreview, LiveDigitalSDK.LiveDigitalEngineError>
  func startVideoSource(id: LiveDigitalSDK.MediaSourceId?, encodingParameters: LiveDigitalSDK.VideoEncodingParameters, preferredCodec: LiveDigitalSDK.VideoCodec, position: AVFoundation.AVCaptureDevice.Position) -> Swift.Result<LiveDigitalSDK.VideoSourceWithPreview, LiveDigitalSDK.LiveDigitalEngineError>
  func stopVideoSource(_ videoSource: any LiveDigitalSDK.VideoSource)
  func addOutput(_ output: AVFoundation.AVCaptureOutput)
  func removeOutput(_ output: AVFoundation.AVCaptureOutput)
}
@available(iOSApplicationExtension, unavailable, message: "Unavailable in extensions.")
@available(watchOSApplicationExtension, unavailable, message: "Unavailable in extensions.")
@available(tvOSApplicationExtension, unavailable, message: "Unavailable in extensions.")
public typealias LiveDigitalEngine = LiveDigitalSDK.LiveDigitalCameraEngine & LiveDigitalSDK.LiveDigitalMicrophoneEngine & LiveDigitalSDK.LiveDigitalSessionManager & LiveDigitalSDK.LiveDigitalVideoFilterEngine
public enum LiveDigitalEngineError : Foundation.LocalizedError {
  case connectionFailed
  case noCameraPermission
  case noMicrophonePermission
  case cameraNotAvailable
  case sourceNotFound
  case captureFailed
  case configurationFailed
  case sdkVersionUnsupported
  public var errorDescription: Swift.String? {
    get
  }
  public static func == (a: LiveDigitalSDK.LiveDigitalEngineError, b: LiveDigitalSDK.LiveDigitalEngineError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOSApplicationExtension, unavailable, message: "Unavailable in extensions.")
@available(watchOSApplicationExtension, unavailable, message: "Unavailable in extensions.")
@available(tvOSApplicationExtension, unavailable, message: "Unavailable in extensions.")
public protocol LiveDigitalMicrophoneEngine {
  var audioSources: [LiveDigitalSDK.AudioSource] { get }
  var audioRouter: any LiveDigitalSDK.AudioRouter { get }
  func startAudioSource() -> Swift.Result<LiveDigitalSDK.AudioSource, LiveDigitalSDK.LiveDigitalEngineError>
  func startAudioSource(encodingParameters: LiveDigitalSDK.AudioEncodingParameters) -> Swift.Result<LiveDigitalSDK.AudioSource, LiveDigitalSDK.LiveDigitalEngineError>
  func stopAudioSource(_ audioSource: LiveDigitalSDK.AudioSource)
}
public struct LiveDigitalSDKEnvironment {
  public let loadBalancerHost: Foundation.URL
  public let analyticsHost: Foundation.URL
  public init(loadBalancerHost: Foundation.URL, analyticsHost: Foundation.URL)
}
extension LiveDigitalSDK.LiveDigitalSDKEnvironment {
  public static var production: LiveDigitalSDK.LiveDigitalSDKEnvironment {
    get
  }
}
public typealias ConnectionCompletion = (Swift.Result<any LiveDigitalSDK.ChannelSession & LiveDigitalSDK.ObservableChannelSession, LiveDigitalSDK.LiveDigitalEngineError>) -> Swift.Void
public protocol LiveDigitalSessionManager {
  var logger: any LiveDigitalSDK.LDSDKLogger { get }
  var currentChannelSession: (any LiveDigitalSDK.ChannelSession)? { get }
  func connectToChannel(_ channelId: LiveDigitalSDK.ChannelId, mediaRole: LiveDigitalSDK.MediaRole?, participantId: LiveDigitalSDK.ParticipantId?, signalingToken: Swift.String?, peerId: LiveDigitalSDK.PeerId?, completion: @escaping LiveDigitalSDK.ConnectionCompletion)
  func connectToChannel(_ channelId: LiveDigitalSDK.ChannelId, mediaRole: LiveDigitalSDK.MediaRole?, participantId: LiveDigitalSDK.ParticipantId?, signalingToken: Swift.String?, peerId: LiveDigitalSDK.PeerId?, peerPayload: [Swift.String : Any]?, completion: @escaping LiveDigitalSDK.ConnectionCompletion)
  func disconnectFromCurrentChannel(completion: @escaping () -> Swift.Void)
}
extension LiveDigitalSDK.LiveDigitalSessionManager {
  public func connectToChannel(_ channelId: LiveDigitalSDK.ChannelId, mediaRole: LiveDigitalSDK.MediaRole?, participantId: LiveDigitalSDK.ParticipantId?, signalingToken: Swift.String?, peerId: LiveDigitalSDK.PeerId?, completion: @escaping LiveDigitalSDK.ConnectionCompletion)
  public func connectToChannel(_ channelId: LiveDigitalSDK.ChannelId, mediaRole: LiveDigitalSDK.MediaRole?, peerPayload: [Swift.String : Any]?, completion: @escaping LiveDigitalSDK.ConnectionCompletion)
}
public protocol LiveDigitalSessionManagerDelegate : AnyObject {
  func sessionManagerFailed(_ manager: any LiveDigitalSDK.LiveDigitalSessionManager, error: LiveDigitalSDK.LiveDigitalEngineError)
}
extension LiveDigitalSDK.LiveDigitalSessionManagerDelegate {
  public func sessionManagerFailed(_ manager: any LiveDigitalSDK.LiveDigitalSessionManager, error: LiveDigitalSDK.LiveDigitalEngineError)
}
@available(iOSApplicationExtension, unavailable, message: "Unavailable in extensions.")
@available(watchOSApplicationExtension, unavailable, message: "Unavailable in extensions.")
@available(tvOSApplicationExtension, unavailable, message: "Unavailable in extensions.")
final public class StockLiveDigitalEngine {
  weak final public var delegate: (any LiveDigitalSDK.AudioRouterDelegate & LiveDigitalSDK.CameraManagerDelegate & LiveDigitalSDK.LiveDigitalSessionManagerDelegate)?
  final public var videoSourcesWithPreview: [LiveDigitalSDK.VideoSourceWithPreview] {
    get
  }
  final public var audioSources: [LiveDigitalSDK.AudioSource] {
    get
  }
  final public let logger: any LiveDigitalSDK.LDSDKLogger
  public init(environment: LiveDigitalSDK.LiveDigitalSDKEnvironment = .production, clientUniqueId: LiveDigitalSDK.ClientUniqueId = .random(), logConfig: LiveDigitalSDK.LogConfig = .defaultConfig)
  @objc deinit
}
@available(iOSApplicationExtension, unavailable, message: "Unavailable in extensions.")
@available(watchOSApplicationExtension, unavailable, message: "Unavailable in extensions.")
@available(tvOSApplicationExtension, unavailable, message: "Unavailable in extensions.")
extension LiveDigitalSDK.StockLiveDigitalEngine : LiveDigitalSDK.LiveDigitalSessionManager {
  final public var currentChannelSession: (any LiveDigitalSDK.ChannelSession)? {
    get
  }
  final public func connectToChannel(_ channelId: LiveDigitalSDK.ChannelId, mediaRole: LiveDigitalSDK.MediaRole?, participantId: LiveDigitalSDK.ParticipantId?, signalingToken: Swift.String?, peerId: LiveDigitalSDK.PeerId?, peerPayload: [Swift.String : Any]?, completion: @escaping LiveDigitalSDK.ConnectionCompletion)
  final public func disconnectFromCurrentChannel(completion: @escaping () -> Swift.Void)
}
@available(iOSApplicationExtension, unavailable, message: "Unavailable in extensions.")
@available(watchOSApplicationExtension, unavailable, message: "Unavailable in extensions.")
@available(tvOSApplicationExtension, unavailable, message: "Unavailable in extensions.")
extension LiveDigitalSDK.StockLiveDigitalEngine : LiveDigitalSDK.LiveDigitalVideoFilterEngine {
  final public var filter: (any LiveDigitalSDK.VideoSourceFilter)? {
    get
    set
  }
}
@available(iOSApplicationExtension, unavailable, message: "Unavailable in extensions.")
@available(watchOSApplicationExtension, unavailable, message: "Unavailable in extensions.")
@available(tvOSApplicationExtension, unavailable, message: "Unavailable in extensions.")
extension LiveDigitalSDK.StockLiveDigitalEngine : LiveDigitalSDK.LiveDigitalCameraEngine {
  final public var cameraManager: any LiveDigitalSDK.CameraManager {
    get
  }
  final public var videoSources: [any LiveDigitalSDK.VideoSource] {
    get
  }
  final public func startVideoSource(position: AVFoundation.AVCaptureDevice.Position) -> Swift.Result<LiveDigitalSDK.VideoSourceWithPreview, LiveDigitalSDK.LiveDigitalEngineError>
  final public func startVideoSource(encodingParameters: LiveDigitalSDK.VideoEncodingParameters, preferredCodec: LiveDigitalSDK.VideoCodec, position: AVFoundation.AVCaptureDevice.Position) -> Swift.Result<LiveDigitalSDK.VideoSourceWithPreview, LiveDigitalSDK.LiveDigitalEngineError>
  final public func startVideoSource(id: LiveDigitalSDK.MediaSourceId?, encodingParameters: LiveDigitalSDK.VideoEncodingParameters, preferredCodec: LiveDigitalSDK.VideoCodec, position: AVFoundation.AVCaptureDevice.Position) -> Swift.Result<LiveDigitalSDK.VideoSourceWithPreview, LiveDigitalSDK.LiveDigitalEngineError>
  final public func stopVideoSource(_ videoSource: any LiveDigitalSDK.VideoSource)
  final public func addOutput(_ output: AVFoundation.AVCaptureOutput)
  final public func removeOutput(_ output: AVFoundation.AVCaptureOutput)
}
@available(iOSApplicationExtension, unavailable, message: "Unavailable in extensions.")
@available(watchOSApplicationExtension, unavailable, message: "Unavailable in extensions.")
@available(tvOSApplicationExtension, unavailable, message: "Unavailable in extensions.")
extension LiveDigitalSDK.StockLiveDigitalEngine : LiveDigitalSDK.LiveDigitalMicrophoneEngine {
  final public var audioRouter: any LiveDigitalSDK.AudioRouter {
    get
  }
  public static func prepareAudioSession(logger: (any LiveDigitalSDK.LDSDKLogger)? = nil)
  final public func startAudioSource() -> Swift.Result<LiveDigitalSDK.AudioSource, LiveDigitalSDK.LiveDigitalEngineError>
  final public func startAudioSource(encodingParameters: LiveDigitalSDK.AudioEncodingParameters) -> Swift.Result<LiveDigitalSDK.AudioSource, LiveDigitalSDK.LiveDigitalEngineError>
  final public func stopAudioSource(_ audioSource: LiveDigitalSDK.AudioSource)
}
@available(iOSApplicationExtension, unavailable, message: "Unavailable in extensions.")
@available(watchOSApplicationExtension, unavailable, message: "Unavailable in extensions.")
@available(tvOSApplicationExtension, unavailable, message: "Unavailable in extensions.")
extension LiveDigitalSDK.StockLiveDigitalEngine : LiveDigitalSDK.CameraManagerDelegate {
  final public func cameraManagerFailed(cameraManager: any LiveDigitalSDK.CameraManager, error: LiveDigitalSDK.MediaCapturerError)
  final public func cameraManagerSwitchedCamera(cameraManager: any LiveDigitalSDK.CameraManager, to position: AVFoundation.AVCaptureDevice.Position?)
}
@available(iOSApplicationExtension, unavailable, message: "Unavailable in extensions.")
@available(watchOSApplicationExtension, unavailable, message: "Unavailable in extensions.")
@available(tvOSApplicationExtension, unavailable, message: "Unavailable in extensions.")
extension LiveDigitalSDK.StockLiveDigitalEngine : LiveDigitalSDK.AudioRouterDelegate {
  final public func routesChanged(in audioRouter: any LiveDigitalSDK.AudioRouter)
  final public func needRestartAudio()
}
public protocol LiveDigitalVideoFilterEngine : AnyObject {
  var filter: (any LiveDigitalSDK.VideoSourceFilter)? { get set }
}
public enum LiveDigital {
  public static func version() -> Swift.String
}
public struct AudioRoute {
  public let kind: LiveDigitalSDK.AudioRoute.Kind
}
extension LiveDigitalSDK.AudioRoute : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension LiveDigitalSDK.AudioRoute : Swift.Equatable {
  public static func == (lhs: LiveDigitalSDK.AudioRoute, rhs: LiveDigitalSDK.AudioRoute) -> Swift.Bool
}
extension LiveDigitalSDK.AudioRoute : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension LiveDigitalSDK.AudioRoute {
  public enum Kind {
    case internalEarSpeaker
    case internalLoudspeaker
    case headset
    case bluetooth(title: Swift.String)
    case bluetoothHeadset(title: Swift.String)
    case external(title: Swift.String)
    case muted
    case noAudio
  }
}
extension LiveDigitalSDK.AudioRoute.Kind : Swift.Equatable {
  public static func == (lhs: LiveDigitalSDK.AudioRoute.Kind, rhs: LiveDigitalSDK.AudioRoute.Kind) -> Swift.Bool
}
public protocol AudioRouter {
  var currentRoute: LiveDigitalSDK.AudioRoute { get }
  var availableRoutes: [LiveDigitalSDK.AudioRoute] { get }
  func updatePreferred(route: LiveDigitalSDK.AudioRoute)
}
public protocol AudioRouterDelegate : AnyObject {
  func routesChanged(in audioRouter: any LiveDigitalSDK.AudioRouter)
  func needRestartAudio()
}
extension LiveDigitalSDK.AudioRouterDelegate {
  public func routesChanged(in audioRouter: any LiveDigitalSDK.AudioRouter)
}
public protocol CameraManager {
  var cameraPosition: Combine.Published<AVFoundation.AVCaptureDevice.Position?>.Publisher { get }
  var currentCameraPosition: AVFoundation.AVCaptureDevice.Position? { get }
  var currentFormat: LiveDigitalSDK.VideoOutputFormat? { get }
  @discardableResult
  func updatePreferred(format: LiveDigitalSDK.VideoOutputFormat) -> Swift.Result<Swift.Void, LiveDigitalSDK.MediaCapturerError>
  @discardableResult
  func updatePreferred(cameraPosition: AVFoundation.AVCaptureDevice.Position) -> Swift.Result<Swift.Void, LiveDigitalSDK.MediaCapturerError>
  @discardableResult
  func flipCamera() -> Swift.Result<Swift.Void, LiveDigitalSDK.MediaCapturerError>
}
public protocol CameraManagerDelegate : AnyObject {
  func cameraManagerSwitchedCamera(cameraManager: any LiveDigitalSDK.CameraManager, to position: AVFoundation.AVCaptureDevice.Position?)
  func cameraManagerFailed(cameraManager: any LiveDigitalSDK.CameraManager, error: LiveDigitalSDK.MediaCapturerError)
}
extension LiveDigitalSDK.CameraManagerDelegate {
  public func cameraManagerSwitchedCamera(cameraManager: any LiveDigitalSDK.CameraManager, to position: AVFoundation.AVCaptureDevice.Position?)
  public func cameraManagerFailed(cameraManager: any LiveDigitalSDK.CameraManager, error: LiveDigitalSDK.MediaCapturerError)
}
public enum MediaCapturerError : Swift.Error {
  case noCameraPermission
  case noMicrophonePermission
  case noCamera
  case captureSessionIsInterrupted
  case failedToStartCapture
  case updateFormatOnRunningSourceNotSupported
  public static func == (a: LiveDigitalSDK.MediaCapturerError, b: LiveDigitalSDK.MediaCapturerError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct VideoOutputFormat {
  public init(size: LiveDigitalSDK.VideoSize, framerate: Swift.Int)
  public init(size: LiveDigitalSDK.VideoSize, framerate: Swift.Int32)
}
extension LiveDigitalSDK.VideoOutputFormat : Swift.Equatable {
  public static func == (a: LiveDigitalSDK.VideoOutputFormat, b: LiveDigitalSDK.VideoOutputFormat) -> Swift.Bool
}
public struct VideoSize {
  public init(size: CoreFoundation.CGSize)
  public init(width: Swift.Int, height: Swift.Int)
  public init(width: Swift.Int32, height: Swift.Int32)
}
extension LiveDigitalSDK.VideoSize : Swift.Equatable {
  public static func == (a: LiveDigitalSDK.VideoSize, b: LiveDigitalSDK.VideoSize) -> Swift.Bool
}
public enum AudioCodec {
  case opus
  public static func == (a: LiveDigitalSDK.AudioCodec, b: LiveDigitalSDK.AudioCodec) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension LiveDigitalSDK.AudioCodec : LiveDigitalSDK.MIMETyped {
  public var mimeTypeString: Swift.String {
    get
  }
}
@_hasMissingDesignatedInitializers final public class AudioSource : LiveDigitalSDK.MediaSource {
  final public let id: LiveDigitalSDK.MediaSourceId
  final public let trackLabel: LiveDigitalSDK.TrackLabel
  final public let encodings: [WebRTC.RTCRtpEncodingParameters]?
  final public let scalabilityMode: Swift.String?
  final public let codecOptions: Swift.String?
  final public var preferredAudioCodec: LiveDigitalSDK.AudioCodec
  final public var preferredCodec: any LiveDigitalSDK.MIMETyped {
    get
  }
  @objc deinit
}
extension LiveDigitalSDK.AudioSource : LiveDigitalSDK.TrackSource {
  final public var track: WebRTC.RTCMediaStreamTrack {
    get
  }
  final public var kind: LiveDigitalSDK.MediaKind {
    get
  }
}
extension LiveDigitalSDK.AudioSource : Swift.CustomStringConvertible {
  final public var description: Swift.String {
    get
  }
}
public protocol CameraPreview : UIKit.UIView {
  var mirrored: Swift.Bool { get set }
  var isEnabled: Swift.Bool { get set }
}
public protocol MIMETyped : Swift.Equatable {
  var mimeTypeString: Swift.String { get }
}
public protocol MediaSource {
  var id: LiveDigitalSDK.MediaSourceId { get }
  var encodings: [WebRTC.RTCRtpEncodingParameters]? { get }
  var scalabilityMode: Swift.String? { get }
  var codecOptions: Swift.String? { get }
  var preferredCodec: any LiveDigitalSDK.MIMETyped { get }
}
public struct MediaSourceId : Swift.RawRepresentable, Swift.Sendable, Swift.Hashable, Swift.Equatable {
  public let rawValue: Foundation.UUID
  public init(rawValue: Foundation.UUID)
  public typealias RawValue = Foundation.UUID
}
extension LiveDigitalSDK.VLMTLVideoView : LiveDigitalSDK.CameraPreview {
}
public enum TrackLabel : Swift.Sendable, Swift.Hashable, Swift.Equatable {
  case unknown(Swift.String)
  case camera
  case microphone
  case screenVideo
  case screenAudio
  case customVideo
  case customAudio
  public static func == (a: LiveDigitalSDK.TrackLabel, b: LiveDigitalSDK.TrackLabel) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension LiveDigitalSDK.TrackLabel : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
public protocol TrackSource {
  var track: WebRTC.RTCMediaStreamTrack { get }
  var trackLabel: LiveDigitalSDK.TrackLabel { get }
  var kind: LiveDigitalSDK.MediaKind { get }
}
public enum VideoCodec {
  case h264
  case vp8
  case vp9
  public init?(withName name: Swift.String)
  public static func == (a: LiveDigitalSDK.VideoCodec, b: LiveDigitalSDK.VideoCodec) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension LiveDigitalSDK.VideoCodec : LiveDigitalSDK.MIMETyped {
  public var mimeTypeString: Swift.String {
    get
  }
}
@objc final public class BlurredBackgroundFilter : ObjectiveC.NSObject {
  final public var blurRadius: Swift.Float {
    get
    set
  }
  final public var output: WebRTC.RTCVideoSource?
  public init(blurRadius: Swift.Float, logger: any LiveDigitalSDK.LDSDKLogger)
  convenience public init(logger: any LiveDigitalSDK.LDSDKLogger)
  @objc deinit
}
extension LiveDigitalSDK.BlurredBackgroundFilter : LiveDigitalSDK.VideoSourceFilter {
  @objc final public func capturer(_ capturer: WebRTC.RTCVideoCapturer, didCapture frame: WebRTC.RTCVideoFrame)
  final public func process(frame: WebRTC.RTCVideoFrame) -> WebRTC.RTCVideoFrame
}
@objc final public class ColorVirtualBackgroundFilter : ObjectiveC.NSObject {
  final public var output: WebRTC.RTCVideoSource?
  final public var backgroundColor: UIKit.UIColor {
    get
    set
  }
  public init(backgroundColor: UIKit.UIColor, logger: any LiveDigitalSDK.LDSDKLogger)
  @objc deinit
}
extension LiveDigitalSDK.ColorVirtualBackgroundFilter : LiveDigitalSDK.VideoSourceFilter {
  @objc final public func capturer(_ capturer: WebRTC.RTCVideoCapturer, didCapture frame: WebRTC.RTCVideoFrame)
  final public func process(frame: WebRTC.RTCVideoFrame) -> WebRTC.RTCVideoFrame
}
@objc final public class ImageVirtualBackgroundFilter : ObjectiveC.NSObject {
  final public var output: WebRTC.RTCVideoSource?
  public init(bgImage: UIKit.UIImage, logger: any LiveDigitalSDK.LDSDKLogger)
  @objc deinit
}
extension LiveDigitalSDK.ImageVirtualBackgroundFilter : LiveDigitalSDK.VideoSourceFilter {
  @objc final public func capturer(_ capturer: WebRTC.RTCVideoCapturer, didCapture frame: WebRTC.RTCVideoFrame)
  final public func process(frame: WebRTC.RTCVideoFrame) -> WebRTC.RTCVideoFrame
}
public protocol VideoSourceFilter : WebRTC.RTCVideoCapturerDelegate {
  var output: WebRTC.RTCVideoSource? { get set }
  func process(frame: WebRTC.RTCVideoFrame) -> WebRTC.RTCVideoFrame
}
public protocol VideoSource : LiveDigitalSDK.MediaSource, LiveDigitalSDK.TrackSource {
  var suspended: Swift.Bool { get }
  var format: LiveDigitalSDK.VideoOutputFormat? { get }
  var preferredVideoCodec: LiveDigitalSDK.VideoCodec { get }
  func subscribe(_ observer: any LiveDigitalSDK.VideoSourceObserver)
  func unsubscribe(_ observer: any LiveDigitalSDK.VideoSourceObserver)
}
extension LiveDigitalSDK.VideoSource {
  public var preferredCodec: any LiveDigitalSDK.MIMETyped {
    get
  }
}
public protocol VideoSourceObserver {
  func videoSourceSuspended(_ videoSource: any LiveDigitalSDK.VideoSource)
  func videoSourceResumed(_ videoSource: any LiveDigitalSDK.VideoSource)
}
@_hasMissingDesignatedInitializers final public class VideoSourceWithPreview {
  public typealias CameraPreviewView = UIKit.UIView & LiveDigitalSDK.CameraPreview
  final public let trackLabel: LiveDigitalSDK.TrackLabel
  final public let id: LiveDigitalSDK.MediaSourceId
  final public let encodings: [WebRTC.RTCRtpEncodingParameters]?
  final public let scalabilityMode: Swift.String?
  final public let codecOptions: Swift.String?
  final public let preferredVideoCodec: LiveDigitalSDK.VideoCodec
  final public var localVideoView: any UIKit.UIView & LiveDigitalSDK.CameraPreview {
    get
  }
  final public var suspended: Swift.Bool {
    get
  }
  @objc deinit
}
extension LiveDigitalSDK.VideoSourceWithPreview {
  final public func startPreview() -> any UIKit.UIView & LiveDigitalSDK.CameraPreview
  final public func stopPreview(_ view: any UIKit.UIView & LiveDigitalSDK.CameraPreview)
}
extension LiveDigitalSDK.VideoSourceWithPreview : LiveDigitalSDK.VideoSource {
  final public var format: LiveDigitalSDK.VideoOutputFormat? {
    get
  }
  final public func subscribe(_ observer: any LiveDigitalSDK.VideoSourceObserver)
  final public func unsubscribe(_ observer: any LiveDigitalSDK.VideoSourceObserver)
}
extension LiveDigitalSDK.VideoSourceWithPreview : LiveDigitalSDK.TrackSource {
  final public var track: WebRTC.RTCMediaStreamTrack {
    get
  }
  final public var kind: LiveDigitalSDK.MediaKind {
    get
  }
}
extension LiveDigitalSDK.VideoSourceWithPreview : Swift.CustomStringConvertible {
  final public var description: Swift.String {
    get
  }
}
@_hasMissingDesignatedInitializers final public class VideoSourceWithoutPreview {
  final public let trackLabel: LiveDigitalSDK.TrackLabel
  final public let id: LiveDigitalSDK.MediaSourceId
  final public let encodings: [WebRTC.RTCRtpEncodingParameters]?
  final public let scalabilityMode: Swift.String?
  final public let codecOptions: Swift.String?
  final public let preferredVideoCodec: LiveDigitalSDK.VideoCodec
  final public var suspended: Swift.Bool {
    get
  }
  @objc deinit
}
extension LiveDigitalSDK.VideoSourceWithoutPreview : LiveDigitalSDK.VideoSource {
  final public var format: LiveDigitalSDK.VideoOutputFormat? {
    get
  }
  final public func subscribe(_ observer: any LiveDigitalSDK.VideoSourceObserver)
  final public func unsubscribe(_ observer: any LiveDigitalSDK.VideoSourceObserver)
}
extension LiveDigitalSDK.VideoSourceWithoutPreview : LiveDigitalSDK.TrackSource {
  final public var track: WebRTC.RTCMediaStreamTrack {
    get
  }
  final public var kind: LiveDigitalSDK.MediaKind {
    get
  }
}
extension LiveDigitalSDK.VideoSourceWithoutPreview : Swift.CustomStringConvertible {
  final public var description: Swift.String {
    get
  }
}
public struct ClientUniqueId : Swift.RawRepresentable, Swift.Hashable, Swift.Equatable, Swift.Codable {
  public let rawValue: Swift.String
  public init(rawValue: Swift.String)
  public static func random() -> LiveDigitalSDK.ClientUniqueId
  public typealias RawValue = Swift.String
}
extension LiveDigitalSDK.ClientUniqueId : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
public struct ActivityRequiredEventData {
  public let time: Foundation.TimeInterval
}
public class AudioEncodingParameters {
  public init(presets: [LiveDigitalSDK.AudioEncodingPreset])
  @objc deinit
}
public class AudioEncodingPreset {
  public var isActive: Swift.Bool {
    get
    set
  }
  public var minBitrateBPS: Swift.Int? {
    get
    set
  }
  public var maxBitrateBPS: Swift.Int? {
    get
    set
  }
  public var networkPriority: WebRTC.RTCPriority {
    get
    set
  }
  public init()
  @objc deinit
}
public struct CustomEvent {
  public let name: Swift.String
  public let peerId: LiveDigitalSDK.PeerId?
  public let data: [Swift.String : Any]
}
public struct JoinedPeerParameters {
  public let channelId: Swift.String
  public let appId: Swift.String
  public let role: LiveDigitalSDK.MediaRole
  public let peerId: LiveDigitalSDK.PeerId
}
public enum MediaRole {
  case host
  case audience
  public static func == (a: LiveDigitalSDK.MediaRole, b: LiveDigitalSDK.MediaRole) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct ParticipantId {
  public let value: Swift.String
  public init(value: Swift.String)
}
extension LiveDigitalSDK.ParticipantId : Swift.ExpressibleByStringLiteral {
  public init(stringLiteral value: Swift.StringLiteralType)
  public typealias ExtendedGraphemeClusterLiteralType = Swift.StringLiteralType
  public typealias StringLiteralType = Swift.StringLiteralType
  public typealias UnicodeScalarLiteralType = Swift.StringLiteralType
}
extension LiveDigitalSDK.ParticipantId : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension LiveDigitalSDK.ParticipantId : Swift.Equatable {
  public static func == (a: LiveDigitalSDK.ParticipantId, b: LiveDigitalSDK.ParticipantId) -> Swift.Bool
}
extension LiveDigitalSDK.ParticipantId : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@_hasMissingDesignatedInitializers public class Peer {
  public var id: LiveDigitalSDK.PeerId {
    get
  }
  public var uid: Swift.String? {
    get
  }
  public var payload: [Swift.String : Any]? {
    get
  }
  public var deadTracks: Swift.Set<LiveDigitalSDK.TrackDescriptor> {
    get
  }
  public var producePermissions: Swift.Set<LiveDigitalSDK.TrackLabel>? {
    get
  }
  public var groups: Swift.Set<LiveDigitalSDK.ChannelGroup>? {
    get
  }
  public var tracks: [LiveDigitalSDK.TrackDescriptor] {
    get
  }
  @objc deinit
}
extension LiveDigitalSDK.Peer {
  public static func mock(id: LiveDigitalSDK.PeerId, uid: Swift.String? = nil, payload: [Swift.String : Any]?, tracks: [LiveDigitalSDK.TrackLabel : LiveDigitalSDK.MediaKind], logger: any LiveDigitalSDK.LDSDKLogger) -> LiveDigitalSDK.Peer
  public func consumingAudio(track: LiveDigitalSDK.TrackLabel) -> Swift.Bool
  public func consumingVideo(track: LiveDigitalSDK.TrackLabel) -> Swift.Bool
  public func producing(_ trackLabel: LiveDigitalSDK.TrackLabel) -> Swift.Bool
  public func layers(for trackLabel: LiveDigitalSDK.TrackLabel) -> [LiveDigitalSDK.VideoLayer]?
}
extension LiveDigitalSDK.Peer : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension LiveDigitalSDK.Peer : Swift.Equatable {
  public static func == (lhs: LiveDigitalSDK.Peer, rhs: LiveDigitalSDK.Peer) -> Swift.Bool
}
extension LiveDigitalSDK.Peer : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct PeerAppData {
  public let peerId: LiveDigitalSDK.PeerId
  public let appData: [Swift.String : Any]
}
public struct PeerId : Swift.RawRepresentable, Swift.Sendable, Swift.Hashable, Swift.Equatable {
  public let rawValue: Swift.String
  public init(rawValue: Swift.String)
  public static func random() -> LiveDigitalSDK.PeerId
  public typealias RawValue = Swift.String
}
extension LiveDigitalSDK.PeerId : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension LiveDigitalSDK.PeerId : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct PeerTrackId : Swift.Hashable {
  public let peer: LiveDigitalSDK.PeerId
  public let track: LiveDigitalSDK.TrackLabel
  public init(peer: LiveDigitalSDK.PeerId, track: LiveDigitalSDK.TrackLabel)
  public static func == (a: LiveDigitalSDK.PeerTrackId, b: LiveDigitalSDK.PeerTrackId) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum ChannelGroup : Swift.Hashable {
  case moderator
  case user
  case other(Swift.String)
  public static func == (a: LiveDigitalSDK.ChannelGroup, b: LiveDigitalSDK.ChannelGroup) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct ChannelProducePermissionsChange {
  public let groups: Swift.Set<LiveDigitalSDK.ChannelGroup>
  public let producePermissions: Swift.Set<LiveDigitalSDK.TrackLabel>
  public let changedProducePermissions: Swift.Set<LiveDigitalSDK.TrackLabel>
}
public struct PeerGroupsChange {
  public let peer: LiveDigitalSDK.PeerId
  public let groups: Swift.Set<LiveDigitalSDK.ChannelGroup>
}
public struct PeerProducePermissions {
  public let peerId: LiveDigitalSDK.PeerId
  public let producePermissions: Swift.Set<LiveDigitalSDK.TrackLabel>
}
public struct TrackDescriptor : Swift.Hashable, Swift.Equatable {
  public let id: LiveDigitalSDK.ProducerId
  public let label: LiveDigitalSDK.TrackLabel
  public static func == (a: LiveDigitalSDK.TrackDescriptor, b: LiveDigitalSDK.TrackDescriptor) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct TrackTrafficReport : Swift.Hashable {
  public let peerId: LiveDigitalSDK.PeerId
  public let trackLabel: LiveDigitalSDK.TrackLabel
  public let producerId: LiveDigitalSDK.ProducerId
  public let consumerId: LiveDigitalSDK.ConsumerId
  public let traffic: Swift.Int?
  public static func == (a: LiveDigitalSDK.TrackTrafficReport, b: LiveDigitalSDK.TrackTrafficReport) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public class VideoEncodingParameters {
  public init(presets: [LiveDigitalSDK.VideoEncodingPreset], scalabilityMode: Swift.String?, startBitrateBPS: Swift.Int?)
  @objc deinit
}
public class VideoEncodingPreset {
  public var isActive: Swift.Bool {
    get
    set
  }
  public var minBitrateBPS: Swift.Int? {
    get
    set
  }
  public var maxBitrateBPS: Swift.Int? {
    get
    set
  }
  public var maxFramerate: Swift.Int? {
    get
    set
  }
  public var numTemporalLayers: Swift.Int? {
    get
    set
  }
  public var scaleResolutionDownBy: Swift.Int? {
    get
    set
  }
  public var networkPriority: WebRTC.RTCPriority {
    get
    set
  }
  public init()
  @objc deinit
}
public enum VideoLayer {
  case low(LiveDigitalSDK.VideoLayer.Properties)
  case medium(LiveDigitalSDK.VideoLayer.Properties)
  case high(LiveDigitalSDK.VideoLayer.Properties)
  public struct Properties {
  }
}
public protocol SpeakerObserver {
  func activeSpeakersChanged(_ speakers: [LiveDigitalSDK.PeerId])
}
extension AVFAudio.AVAudioSession.RouteChangeReason : @retroactive Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension Foundation.Data {
  public func gunzipped(wBits: Swift.Int32 = MAX_WBITS + 32) throws(LiveDigitalSDK.GzipError) -> Foundation.Data
}
public struct GzipError : Swift.Error, Swift.Sendable {
  public enum Kind : Swift.Equatable, Swift.Sendable {
    case stream
    case data
    case memory
    case buffer
    case version
    case unknown(code: Swift.Int)
    public static func == (a: LiveDigitalSDK.GzipError.Kind, b: LiveDigitalSDK.GzipError.Kind) -> Swift.Bool
  }
  public let kind: LiveDigitalSDK.GzipError.Kind
  public let message: Swift.String
  public var localizedDescription: Swift.String {
    get
  }
}
final public class ExistentialLDSDKLogger {
  public init(logger: any LiveDigitalSDK.LDSDKLogger)
  @objc deinit
}
extension LiveDigitalSDK.ExistentialLDSDKLogger : LiveDigitalSDK.LDSDKLogger {
  final public func setMeta(_ meta: [Swift.String : any Swift.Encodable]?)
  final public func addMeta(_ newMeta: [Swift.String : any Swift.Encodable])
  final public func logVerbose(_ message: @autoclosure @escaping () -> Swift.String, _ error: (any Swift.Error)? = nil, file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line, payload: [Swift.String : any Swift.Encodable]? = nil)
  final public func logDebug(_ message: @autoclosure @escaping () -> Swift.String, _ error: (any Swift.Error)? = nil, file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line, payload: [Swift.String : any Swift.Encodable]? = nil)
  final public func logInfo(_ message: @autoclosure @escaping () -> Swift.String, _ error: (any Swift.Error)? = nil, file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line, payload: [Swift.String : any Swift.Encodable]? = nil)
  final public func logWarn(_ message: @autoclosure @escaping () -> Swift.String, _ error: (any Swift.Error)? = nil, file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line, payload: [Swift.String : any Swift.Encodable]? = nil)
  final public func logError(_ message: @autoclosure @escaping () -> Swift.String, _ error: (any Swift.Error)? = nil, file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line, payload: [Swift.String : any Swift.Encodable]? = nil)
}
public enum LDSDKLogLevel : Swift.Comparable {
  case verbose
  case debug
  case info
  case warning
  case error
  public static func < (a: LiveDigitalSDK.LDSDKLogLevel, b: LiveDigitalSDK.LDSDKLogLevel) -> Swift.Bool
  public static func == (a: LiveDigitalSDK.LDSDKLogLevel, b: LiveDigitalSDK.LDSDKLogLevel) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol LDSDKLogger {
  func setMeta(_ meta: [Swift.String : any Swift.Encodable]?)
  func addMeta(_ newMeta: [Swift.String : any Swift.Encodable])
  func logVerbose(_ message: @autoclosure @escaping () -> Swift.String, _ error: (any Swift.Error)?, file: Swift.StaticString, function: Swift.StaticString, line: Swift.UInt, payload: [Swift.String : any Swift.Encodable]?)
  func logDebug(_ message: @autoclosure @escaping () -> Swift.String, _ error: (any Swift.Error)?, file: Swift.StaticString, function: Swift.StaticString, line: Swift.UInt, payload: [Swift.String : any Swift.Encodable]?)
  func logInfo(_ message: @autoclosure @escaping () -> Swift.String, _ error: (any Swift.Error)?, file: Swift.StaticString, function: Swift.StaticString, line: Swift.UInt, payload: [Swift.String : any Swift.Encodable]?)
  func logWarn(_ message: @autoclosure @escaping () -> Swift.String, _ error: (any Swift.Error)?, file: Swift.StaticString, function: Swift.StaticString, line: Swift.UInt, payload: [Swift.String : any Swift.Encodable]?)
  func logError(_ message: @autoclosure @escaping () -> Swift.String, _ error: (any Swift.Error)?, file: Swift.StaticString, function: Swift.StaticString, line: Swift.UInt, payload: [Swift.String : any Swift.Encodable]?)
}
public enum LogConfig {
  case externalLogger(any LiveDigitalSDK.LDSDKLogger)
  case standard(consoleLogLevel: LiveDigitalSDK.LDSDKLogLevel, remoteLogLevel: LiveDigitalSDK.LDSDKLogLevel, meta: [Swift.String : any Swift.Encodable]?)
  public static var defaultConfig: LiveDigitalSDK.LogConfig
}
extension LiveDigitalSDK.ChannelSessionError : Swift.Equatable {}
extension LiveDigitalSDK.ChannelSessionError : Swift.Hashable {}
extension LiveDigitalSDK.ChannelSessionStatus : Swift.Hashable {}
extension LiveDigitalSDK.MediaKind : Swift.Equatable {}
extension LiveDigitalSDK.MediaKind : Swift.Hashable {}
extension LiveDigitalSDK.MediaKind : Swift.RawRepresentable {}
extension LiveDigitalSDK.NetworkReportDirection : Swift.Equatable {}
extension LiveDigitalSDK.NetworkReportDirection : Swift.Hashable {}
extension LiveDigitalSDK.LiveDigitalEngineError : Swift.Equatable {}
extension LiveDigitalSDK.LiveDigitalEngineError : Swift.Hashable {}
extension LiveDigitalSDK.MediaCapturerError : Swift.Equatable {}
extension LiveDigitalSDK.MediaCapturerError : Swift.Hashable {}
extension LiveDigitalSDK.AudioCodec : Swift.Hashable {}
extension LiveDigitalSDK.VideoCodec : Swift.Hashable {}
extension LiveDigitalSDK.MediaRole : Swift.Equatable {}
extension LiveDigitalSDK.MediaRole : Swift.Hashable {}
extension LiveDigitalSDK.LDSDKLogLevel : Swift.Hashable {}
